\documentclass[pageno]{jpaper}

\newcommand{\IWreport}{2015}

%correct bad hyphenation here
\hyphenation{Comp-Cert}
\hyphenation{Comp-Cert-TSO}
\usepackage[normalem]{ulem}
\usepackage{listings}
\usepackage{lstlangcoq}

\lstset{language=Coq,basicstyle=\sffamily,mathescape=true,columns=fullflexible}

\newcommand{\stdtitle}[1]{\textbf{#1}}

\begin{document}

\title{
Verification of a Deterministic Random Bits Generator
}

\author{Naphat Sanguansin\\Adviser: Andrew W. Appel}

\date{}
\maketitle

\thispagestyle{empty}
\doublespacing
\begin{abstract}
In this project, I formally verified the \stdtitle{mbedTLS} implementation of a HMAC-based deterministic random bits generator (DRBG) with respect to the standard \stdtitle{NIST SP 800-90A}. By “formal”, I mean the verification is in the machine-checked environment of Coq using the Verified Software Toolchain (VST) framework. I verified the functions \lstinline{update}, \lstinline{reseed}, and \lstinline{generate}. Due to time constraint, I was not able to verify the \lstinline{instantiate} function.
\end{abstract}

\section{Introduction}
A DRBG is a program that takes a source of randomness, or entropy, and stretches it out into a string of pseudorandom bits. \stdtitle{NIST SP 800-90A} \cite{nist} DRBG provides backtracking resistance and, optionally, prediction resistance. Backtracking resistance means that even if the whole (secret) state of the DRBG is known at time $t$, the state at time $t - 1$ cannot be computed. Note that this implies the state at time $t - i$ cannot be computed for all $i \geq 1$. Prediction resistance means that even if the whole (secret) state of the DRBG is known at time $t$, the state at time $t + 1$ cannot be computed. Again, note that this implies the state at time $t + i$ cannot be computed for all $i \geq 1$. Here, “time” is counted in terms of calls to the \lstinline{generate} function.

\stdtitle{NIST SP 800-90A} specifies different types of DRBG. The version I verified in this project is the one based on the key-hashed message authentication code, or HMAC. HMAC takes a (secret) key and a message and computes a fixed-length message authentication code. In theory, someone with only the message will not be able to compute the message authentication code, and someone with both the message and the message authentication code will not be able to compute the key.

Why did I choose to verify an implementation of DRBG? In short, DRBG is a widely used crypto primitive. Correctly implemented crypto primitives help application programmers improve the security of their code without them having to fully understand the math behind the crypto algorithms.

\subsection{Machine-Checked Proofs}
I did the verification in Coq, an open-sourced proof assistant. The C code is compiled into its abstract syntax tree (AST) in Coq using the CompCert certified (machine-checked) compiler. I wrote functional specifications (functional programs) in Coq that closely match \stdtitle{NIST SP 800-90A}. Using the functional programs, I created API specifications using the VST framework. API specifications reason about how the AST deals with memory and local variables. I then prove the AST correct with respect to the API specifications.

Of what the tasks I mentioned, the ones that must be trusted are the translation of \stdtitle{NIST SP 800-90A} into functional specifications and the creation of API specifications from those functional programs. Everything else is machine-checked. Can the functional and API specifications be trusted? For the latter, I hope to make a convincing claim by the end of this paper that as long as the functional specifications are correct, the corresponding API specifications will be, too. As for the functional specifications, first of all, they are small, easy-to-reason-about functional programs. I also ran the programs on some test inputs from NIST and verified that the output matches. While this is already a huge step forward from a C program, as a functional program in Coq is less error-prone, it is still unsatisfying that at the functional specification level, I had to resort to unit tests. Thankfully, there is a parallel project by Katherine Ye ‘16 that will prove cryptographic properties of the functional specifications. The fact that this project can be done in parallel to (and mostly independent from) the verification of the C implementation shows the power and flexibility of VST.

\subsection{Related Works}
Similar verifications have been done for SHA-256 and HMAC, see \cite{sha} and \cite{hmac} respectively. As mentioned previously, Katherine Ye ‘16 is working on proving cryptographic properties of the functional specifications.

As far as I could tell, this is the first end-to-end verification of an implementation of HMAC DRBG against a functional specification. By “end-to-end” I mean that the verification builds upon an existing verification of HMAC \cite{hmac} (which is, in turn, built upon an existing verification of SHA-256 \cite{sha}).

There have been some other verification efforts to verify a DRBG, albeit without using a functional specification. As an example, \cite{prng} verified Android’s pseudorandom number generator. This verification is done on a Java implementation, and is a verification on information flow, not on a functional specification. That is, the project proves that all the bytes of entropy are used in constructing the secret internal state. Proving an implementation against a functional specification is arguably better, as it allows the functional specification to serve as a mathematical representation of the more complex C (or Java) implementation. This functional specification can then be shown to have desired cryptographic properties, including the fact that all bytes of entropy are being properly consumed.


\subsection{Why mbedTLS?}

Previous efforts in the VST project to verify SHA-256 \cite{sha} and HMAC \cite{hmac} have done so using \stdtitle{OpenSSL 0.9.1c}. A natural choice for the DRBG verification would be to also use the same \stdtitle{OpenSSL} library. Unfortunately, the DRBG implementation in \stdtitle{OpenSSL} makes heavy use of function pointers to encapsulate the differences between each type of DRBG. While Verifiable C is capable of reasoning about function pointers, the proof automation system is not yet robust enough when dealing with function pointers and so such proofs will be more complex. \stdtitle{mbedTLS}, on the other hand, does not make use of function pointers except to deal with entropy. Therefore, I chose to use the implementation of DRBG found in \stdtitle{mbedTLS 2.1.1}.

\subsection{Modifications to mbedTLS}
I had to make a few modifications to the \stdtitile{mbedTLS} DRBG source file. Most of these transformations are obviously equivalent to the original version. For example, Verifiable C does not allow memory dereferences in function parameters or if/while/for-loop conditions.

Therefore, code such as the following had to be changed:

\begin{lstlisting}[language=C]
    md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
\end{lstlisting}

to this:

\begin{lstlisting}[language=C]
    info = ctx->md_ctx.md_info;
    md_len = mbedtls_md_get_size( info );
\end{lstlisting}

The other modification I had to make was to eliminate the use of function pointers when dealing with entropy.

\section{A Functional Representation of Entropy} \label{entropy}
Before even understanding what a DRBG does, I need to explain how entropy is represented.

A DRBG needs some entropy input to act as a source of randomness. According to \stdtitle{NIST SP 800-90A}, the source of entropy input can be either an approved entropy source, a nondeterministic random bits generator (NRBG), or another DRBG. The entropy API used in NIST is the following:

\begin{lstlisting}
    (status, entropy_input) = Get_entropy_input(min_entropy, min_length, max_length, prediction_resistance_request)
\end{lstlisting}

\lstinline{min_entropy} refers to how many bits of entropy to use. \lstinline{min_length} and \lstinline{max_length} bounds the length of the output string of bits. If \lstinline{prediction_resistance_request} is set, then fresh bits of entropy are used.

For this project, I wanted a simple entropy representation that still satisfies \stdtitle{NIST SP 800-90A}. A flawed idea is to represent entropy as an infinite stream of \lstinline{bool}, each \lstinline{bool} representing a bit. This does not model real-life entropy. Entropy is expensive; if it was not, there would be no need for a DRBG to begin with! Requesting too many bits of entropy when there is insufficient supply can cause a failure. To capture this behavior, I chose to model entropy as an infinite stream of \lstinline{option bool}.

Note that in Coq, as well as many typed programming languages, an \lstinline{option} type is a type that can simply not exist (\lstinline{null} in the language of C and Java). It is effectively equivalent to this:

\begin{lstlisting}
    Inductive option (T: Type) :=
    | Some: T -> option T
    | None: option T.
\end{lstlisting}

A \lstinline{None} value means that the entropy bit is not yet available, and so the call to get entropy should fail. An infinite stream of entropy can be defined as follows:

\begin{lstlisting}
    Definition stream: Type := nat -> option bool.
\end{lstlisting}

The \lstinline{nat} (natural number) argument is used to index into the stream. Note that a simple \lstinline{list} would not work here, because we need the stream to have infinite size.

Any functions that consume entropy will need to return a new entropy stream. Furthermore, because calls to get entropy can fail, such functions have to be able to handle failures. For this reason, I defined a general \lstinline{result} datatype:

\begin{lstlisting}
    Inductive error_code: Type :=
    | catastrophic_error
    | generic_error.

    Inductive result (X: Type): Type :=
    | success: X -> stream -> result X
    | error : error_code -> stream -> result X.
\end{lstlisting}

I also defined a \lstinline{get_bits} function that, if possible, get the consecutive requested number of bits from the stream and returns a new stream that advances the index by the requested number of bits. If \lstinline{get_bits} encounters an error (a \lstinline{None} value), it returns a new stream that skips this error the next time it is called, symbolizing a movement forward in time resulting in more entropy being available.

This stream representation of entropy is a specialized case of the \lstinline{Get_entropy_input} function from \stdtitle{NIST SP 800-90A}, with each bit of the stream representing a bit of entropy, therefore setting \lstinline{min_entropy = min_length = max_length}, with prediction resistance always on. In the language of \stdtitle{NIST SP 800-90A}, this entropy representation is an “ideal random bitstring”.

\section{Preparation Instructions}

\subsection{Paper Formatting}

There are no minimum or maximum length limits on IW reports.
We are including this template because we think it will be helpful
for citing things properly and for including figures into formatted
text.  If you are using \LaTeX~\cite{lamport94}
to typeset your paper, then we strongly suggest
that you start from the template available at
http://iw.cs.princeton.edu -- this
document was prepared with that template.
If you are using a different software package to typeset your paper,
then you can still use this document as a reasonable sample of
how your report might look.  Table~\ref{table:formatting} is a suggestion
of some formatting guidelines, as well as being an example of how to
include a table in a Latex document.

\begin{table}[h!]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Field} & \textbf{Value}\\
    \hline
    \hline
    Paper size & US Letter 8.5in $\times$ 11in\\
    \hline
    Top margin & 1in\\
    \hline
    Bottom margin & 1in\\
    \hline
    Left margin & 1in\\
    \hline
    Right margin & 1in\\
    \hline
    Body font & 12pt\\
    \hline
    Abstract font & 12pt, italicized\\
    \hline
    Section heading font & 14pt, bold\\
    \hline
    Subsection heading font & 12pt, bold\\
    \hline
  \end{tabular}
  \caption{Formatting guidelines. }
  \label{table:formatting}
\end{table}

\textbf{Please ensure that you include page numbers with your
submission}. This makes it easier for readers to refer to
different parts of your paper when they provide comments.

We highly recommend you use bibtex for managing your references and citations.  You can add bib entries to a references.bib file throughout the semester (e.g. as you read papers) and then they will be ready for you to cite when you start writing the report.  If you use bibtex, please note that the references.bib file provided in the template example includes some format-specific incantations at the top of the file.  If you substitute your own bib file, you will probably want to include these
incantations at the top of it.

\subsection{Citations}

There are various reasons to cite prior work and include it as references in your bibliography.  For example, If you are improving upon
prior work, you should include
a full citation for the work in the bibliography \cite{nicepaper,nicepaper2}.
You can also cite information that is used as background or explanation.  In addition to citing scholarly papers or books, you can also create bibtex entries for webpages or other sources.  Many online databases allow you to download a premade bibtex entry for each paper you access.  You can simply copy-paste these into your references.bib file.

\noindent\textbf{Figures and Tables.} Ensure that the figures and
tables are legible.  Please also ensure that you refer to your
figures in the main text. Make sure that your figures will be legible
in the expected forms that the report will be read.  If you expect someone
to print it out in gray-scale, then make sure the figures are legible
when printed that way.

\noindent\textbf{Main Body.} Avoid bad page or column breaks in
your main text, i.e., last line of a paragraph at the top of a
column or first line of a paragraph at the end of a column. If you
begin a new section or sub-section near the end of a column,
ensure that you have at least 2 lines of body text on the same
column.

\subsection{Ethics}

Your independent work report should abide by the basic standards of scholarly ethics and by the Princeton Honor Code. If you have any doubts about how to cite
other work, how to quote or include text or images from other works, or other issues, please discuss them with your project adviser or with the IW coordinators.

\section{Outline}
The following is a possible outline for your paper.
\subsection{Introduction}
\begin{itemize}
\item Problem statement
\item Motivation and goal...The goal of this project is...
\item Roadmap: The remainder of this paper is organized as follows....
\end{itemize}

\subsection{Related Work}
\begin{itemize}
\item Survey of prior work with similar goals
\item Comparison to your project
\end{itemize}

\subsection{Approach}
\begin{itemize}
\item Key novel idea
\end{itemize}

\subsection{Implementation}
\begin{itemize}
\item Things you implemented.  How you did it?
\end{itemize}

\subsection{Evaluation}
\begin{itemize}
\item Experiment design...
\item Data...
\item Metrics...
\item Comparisons...
\item Qualitative results...
\item Quantitative results...
\item Further results needed...
\end{itemize}

\subsection{Summary}
\begin{itemize}
\item Conclusions...
\item Limitations...
\item Future work...
\end{itemize}

\cite{sha}
\cite{hmac}
\cite{prg}
\cite{nist}

\bstctlcite{bstctl:etal, bstctl:nodash, bstctl:simpurl}
\bibliographystyle{IEEEtranS}
\bibliography{references}


\end{document}
